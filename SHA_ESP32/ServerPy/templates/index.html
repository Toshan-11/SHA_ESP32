<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ESP32 Home Control</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .toggle-btn { transition: all 0.3s ease; }
    .toggle-btn:hover { transform: translateY(-2px); }
    .status-on { color: #10B981; font-weight: 600; }
    .status-off { color: #EF4444; font-weight: 600; }
    .status-error { color: #F59E0B; font-weight: 600; }
    .recording { 
      animation: pulse 2s infinite;
      background-color: #EF4444 !important;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

  <div class="max-w-4xl w-full bg-white rounded-2xl shadow-xl p-8 mb-8">
    <h2 class="text-3xl font-bold text-gray-800 mb-8 text-center">ESP32 Home Controller</h2>
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
      <div class="bg-gray-50 p-6 rounded-xl shadow-md flex flex-col items-center">
        <h3 class="text-lg font-semibold text-gray-700 mb-4">Light</h3>
        <button onclick="toggle('light')" class="toggle-btn bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600">Toggle</button>
        <span id="light-status" class="mt-4 text-lg">...</span>
      </div>
      <div class="bg-gray-50 p-6 rounded-xl shadow-md flex flex-col items-center">
        <h3 class="text-lg font-semibold text-gray-700 mb-4">Fan</h3>
        <button onclick="toggle('fan')" class="toggle-btn bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600">Toggle</button>
        <span id="fan-status" class="mt-4 text-lg">...</span>
      </div>
      <div class="bg-gray-50 p-6 rounded-xl shadow-md flex flex-col items-center">
        <h3 class="text-lg font-semibold text-gray-700 mb-4">Door</h3>
        <button onclick="toggle('door')" class="toggle-btn bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600">Toggle</button>
        <span id="door-status" class="mt-4 text-lg">...</span>
      </div>
    </div>
  </div>

  <!-- Live Video Stream Section -->
  <div class="max-w-xl w-full bg-white rounded-2xl shadow-xl p-8">
    <h3 class="text-2xl font-semibold text-gray-800 mb-4 text-center">Live Video Stream</h3>
    <video id="preview" autoplay muted playsinline class="rounded-xl w-full h-auto border mb-4"></video>
    
    <div class="flex justify-center space-x-4 mb-4">
      <button id="startStreamBtn" class="bg-green-500 text-white px-6 py-2 rounded-lg hover:bg-green-600">Start Stream</button>
      <button id="stopStreamBtn" class="bg-red-500 text-white px-6 py-2 rounded-lg hover:bg-red-600" disabled>Stop Stream</button>
    </div>
    
    <div class="text-center">
      <span id="streamStatus" class="text-gray-600">Stream inactive</span>
      <div id="uploadProgress" class="mt-2 text-sm text-blue-600"></div>
    </div>
  </div>

  <script>
    const states = { light: 0, fan: 0, door: 0 };

    function toggle(device) {
      const newState = states[device] ? 0 : 1;
      fetch('/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ device: device, state: newState })
      }).then(() => {
        states[device] = newState;
        updateStatus();
      });
    }

    function updateStatus() {
      fetch('/status')
        .then(res => res.json())
        .then(data => {
          ['light', 'fan', 'door'].forEach(dev => {
            let val = data[dev];
            states[dev] = val;
            const statusElement = document.getElementById(dev + "-status");
            statusElement.innerText = val === 1 ? "ON" : val === 0 ? "OFF" : "Error";
            statusElement.className = val === 1 ? "mt-4 text-lg status-on" : val === 0 ? "mt-4 text-lg status-off" : "mt-4 text-lg status-error";
          });
        });
    }

    setInterval(updateStatus, 2000);
    updateStatus();

    // Live Video Stream Implementation
    const preview = document.getElementById('preview');
    const startStreamBtn = document.getElementById('startStreamBtn');
    const stopStreamBtn = document.getElementById('stopStreamBtn');
    const streamStatus = document.getElementById('streamStatus');
    const uploadProgress = document.getElementById('uploadProgress');

    let mediaRecorder;
    let stream;
    let isStreaming = false;
    let chunkCounter = 0;
    let streamInterval;

    const CHUNK_DURATION_MS = 1000; // Send 1-second chunks
    const STREAM_QUALITY = {
      video: {
        width: { ideal: 640 },
        height: { ideal: 480 },
        frameRate: { ideal: 15 }
      },
      audio: {
        sampleRate: { ideal: 16000 },
        channelCount: { ideal: 1 }
      }
    };

    // Initialize camera
    async function initCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia(STREAM_QUALITY);
        preview.srcObject = stream;
        startStreamBtn.disabled = false;
        streamStatus.textContent = 'Camera ready';
      } catch (err) {
        console.error('Camera access failed:', err);
        streamStatus.textContent = 'Camera access failed: ' + err.message;
      }
    }

    // Start live streaming
    function startLiveStream() {
      if (!stream || isStreaming) return;

      isStreaming = true;
      chunkCounter = 0;
      
      startStreamBtn.disabled = true;
      stopStreamBtn.disabled = false;
      startStreamBtn.classList.add('recording');
      streamStatus.textContent = 'Streaming live...';

      // Create new MediaRecorder for each stream session
      mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9,opus'
      });

      mediaRecorder.ondataavailable = async (event) => {
        if (event.data && event.data.size > 0 && isStreaming) {
          chunkCounter++;
          await sendVideoChunk(event.data, chunkCounter);
        }
      };

      mediaRecorder.onerror = (event) => {
        console.error('MediaRecorder error:', event.error);
        stopLiveStream();
      };

      // Start recording and set up continuous chunking
      mediaRecorder.start();
      
      streamInterval = setInterval(() => {
        if (isStreaming && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          mediaRecorder.start(); // Restart to create new chunk
        }
      }, CHUNK_DURATION_MS);
    }

    // Stop live streaming
    function stopLiveStream() {
      isStreaming = false;
      
      if (streamInterval) {
        clearInterval(streamInterval);
        streamInterval = null;
      }
      
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      
      startStreamBtn.disabled = false;
      stopStreamBtn.disabled = true;
      startStreamBtn.classList.remove('recording');
      streamStatus.textContent = 'Stream stopped';
      uploadProgress.textContent = '';
    }

    // Send video chunk to backend
    async function sendVideoChunk(blob, chunkId) {
      try {
        const timestamp = new Date().toISOString();
        const formData = new FormData();
        formData.append('video', blob, `stream_chunk_${chunkId}_${timestamp}.webm`);
        formData.append('chunk_id', chunkId);
        formData.append('timestamp', timestamp);
        formData.append('is_live_stream', 'true');

        uploadProgress.textContent = `Uploading chunk ${chunkId}...`;

        const response = await fetch('/upload', {
          method: 'POST',
          body: formData
        });

        if (response.ok) {
          uploadProgress.textContent = `Chunk ${chunkId} uploaded successfully`;
          setTimeout(() => {
            if (uploadProgress.textContent.includes(`Chunk ${chunkId}`)) {
              uploadProgress.textContent = '';
            }
          }, 1000);
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error) {
        console.error('Upload failed:', error);
        uploadProgress.textContent = `Upload failed for chunk ${chunkId}`;
      }
    }

    // Event listeners
    startStreamBtn.addEventListener('click', startLiveStream);
    stopStreamBtn.addEventListener('click', stopLiveStream);

    // Initialize camera on page load
    initCamera();

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      stopLiveStream();
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>